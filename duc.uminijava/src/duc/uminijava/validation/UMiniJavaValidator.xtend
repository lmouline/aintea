/*
 * generated by Xtext 2.14.0
 */
package duc.uminijava.validation

import org.eclipse.xtext.validation.Check
import duc.uminijava.uMiniJava.BernoulliRef
import duc.uminijava.uMiniJava.UMiniJavaPackage

import duc.uminijava.typing.UMiniJavaTypeComputer
import duc.uminijava.uMiniJava.NewUObject
import com.google.inject.Inject
import org.tetrabox.minijava.xtext.miniJava.Expression
import duc.uminijava.typing.UMiniJavaTypeConformance

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class UMiniJavaValidator extends AbstractUMiniJavaValidator {
	
	@Inject 
	extension UMiniJavaTypeComputer
	
	@Inject
	extension UMiniJavaTypeConformance
	
	@Check
	def checkNewUType(NewUObject objCreation) {
		if(objCreation.type instanceof BernoulliRef) {
			if(objCreation.args.length != 2) {
				error("Creation of Bernoulli required two arguments.", UMiniJavaPackage.eINSTANCE.newUObject_Args)
				return
			}
			
			if(objCreation.args.get(0).typeFor !== UMiniJavaTypeComputer.BOOLEAN_TYPE) {
				error("First argument should be a boolean expression.", UMiniJavaPackage.eINSTANCE.newUObject_Args,0)
			} 
			
			if(objCreation.args.get(1).typeFor !== UMiniJavaTypeComputer.INT_TYPE) {
				error("Second argument should be a int expression.", UMiniJavaPackage.eINSTANCE.newUObject_Args, 1)
			}
			
		}
	}
	
	@Check override void checkConformance(Expression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
				
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType.name + "' but was '" + actualType.name + "'", null,
				INCOMPATIBLE_TYPES);
		}
	}
	
}
