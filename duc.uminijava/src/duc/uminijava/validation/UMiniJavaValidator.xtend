/*
 * generated by Xtext 2.14.0
 */
package duc.uminijava.validation

import org.eclipse.xtext.validation.Check
import duc.uminijava.uMiniJava.BernoulliRef
import duc.uminijava.uMiniJava.UMiniJavaPackage

import duc.uminijava.typing.UMiniJavaTypeComputer
import duc.uminijava.uMiniJava.NewUObject
import com.google.inject.Inject
import org.tetrabox.minijava.xtext.miniJava.Expression
import duc.uminijava.typing.UMiniJavaTypeConformance
import org.tetrabox.minijava.xtext.miniJava.Or
import org.eclipse.emf.ecore.EReference
import org.tetrabox.minijava.xtext.miniJava.MiniJavaPackage
import org.tetrabox.minijava.xtext.miniJava.And
import org.tetrabox.minijava.xtext.miniJava.Not
import org.tetrabox.minijava.xtext.miniJava.ArrayAccess
import org.tetrabox.minijava.xtext.miniJava.TypeDeclaration

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class UMiniJavaValidator extends AbstractUMiniJavaValidator {
	
	@Inject 
	extension UMiniJavaTypeComputer
	
	@Inject
	extension UMiniJavaTypeConformance
	
	@Check
	def checkNewUType(NewUObject objCreation) {
		if(objCreation.type instanceof BernoulliRef) {
			if(objCreation.args.length != 2) {
				error("Creation of Bernoulli required two arguments.", UMiniJavaPackage.eINSTANCE.newUObject_Args)
				return
			}
			
			if(objCreation.args.get(0).typeFor !== UMiniJavaTypeComputer.BOOLEAN_TYPE) {
				error("First argument should be a boolean expression.", UMiniJavaPackage.eINSTANCE.newUObject_Args,0)
			} 
			
			if(objCreation.args.get(1).typeFor !== UMiniJavaTypeComputer.INT_TYPE) {
				error("Second argument should be a int expression.", UMiniJavaPackage.eINSTANCE.newUObject_Args, 1)
			}
			
		}
	}
	
	@Check override void checkConformance(Expression exp) {
		val actualType = exp.typeFor
		val expectedType = exp.expectedType
		
		println('''For «exp»
		   «exp.eContainer»
		   «actualType»
		   «expectedType»
		''')
				
		if (expectedType === null || actualType === null)
			return; // nothing to check
		if (!actualType.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType.name + "' but was '" + actualType.name + "'", null,
				INCOMPATIBLE_TYPES);
		}
	}

	@Check
	override dispatch checkType(Or or) {
		checkBooleanOrUBoolen(or.left, MiniJavaPackage.eINSTANCE.or_Left)
		checkBooleanOrUBoolen(or.right, MiniJavaPackage.eINSTANCE.or_Right)
	}
	
	@Check
	override dispatch checkType(And and) {
		checkBooleanOrUBoolen(and.left, MiniJavaPackage.eINSTANCE.and_Left)
		checkBooleanOrUBoolen(and.right, MiniJavaPackage.eINSTANCE.and_Right)
	}
	
	@Check
	override dispatch checkType(Not not) {
		checkBooleanOrUBoolen(not.expression, MiniJavaPackage.eINSTANCE.and_Left)
	}
	
	def private checkBooleanOrUBoolen(Expression exp, EReference ref) {
		if(exp.typeFor !== UMiniJavaTypeComputer.BOOLEAN_TYPE && exp.typeFor !== UMiniJavaTypeComputer.BERNOULLI_TYPE) {
			error("Should be boolean or Bernoulli", ref, INCOMPATIBLE_TYPES)
		}
	}
	
	@Check
	override dispatch checkType(ArrayAccess arrayAccess) {
		val TypeDeclaration objectType = arrayAccess.object.typeFor
		if(!objectType.isArray && objectType !== UMiniJavaTypeComputer.BERNOULLI_TYPE) {
			error('''Should be an array or a Bernoulli type. Actual type: «objectType.name»''', MiniJavaPackage.eINSTANCE.arrayAccess_Object, INCOMPATIBLE_TYPES)
		}
	}
	
	
	
}
